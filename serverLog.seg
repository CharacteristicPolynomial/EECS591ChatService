/* log structure
viewChange view_number
acceptorLog clientIP clientPort requestlen request requestID position view_number
learnerLog clientIP clientPort request requestID position
*/

// for convenience of debugging, we will use a english style log
// remember request is a pair (requestlen, request)
// remember clientIP is of type struct sockaddr_in

void parselog() {
    ifstream ifs;
    ifs.open(logfile);
    string header;
    string ip, request;
    unsigned short port;
    int requestID, position, view_number;
    struct sockaddr_in temp;
    while(ifs >> header) {
        if (header == "viewChange") {
            ifs >> view;
        } else if (header == "acceptorLog") {
            ifs >> ip >> port >> request >> requestID >> position >> view_number;
            if (acceptLog.size() <= position) {
                // increase log size if needed
                acceptLog.resize(position+1);
            }
            if (view_number > acceptLog[position].second) {
                memset((char *)&temp, 0, sizeof(temp));
                temp.sin_family = AF_INET;
                inet_pton(AF_INET, ip.c_str(), &temp.sin_addr);
                temp.sin_port = htons(port);
                acceptLog[position].first = Request(temp, request, requestID);
            }
        } else if (header == "learnerLog") {
            ifs >> ip >> port >> request >> requestID >> position;
            if (chatLog.size() <= position) {
                // increase log size if needed
                chatLog.resize(position+1);
            }
            // the protocol guranteed the learned value is always the same, as a result, we don't need to learn learned slot
            memset((char *)&temp, 0, sizeof(temp));
            temp.sin_family = AF_INET;
            inet_pton(AF_INET, ip.c_str(), &temp.sin_addr);
            temp.sin_port = htons(port);
            chatLog[position] = Request(temp, request, requestID);            
        } else {
            cerr << "Parse error: unknown header: " << header << endl;
            exit(-1);
        }
    }    
    ifs.close();
}

void encodeHeartBeat(char* buf) {
    char temp[BUFFER_SIZE];
    HEADER header = HEARTBEAT;
    memcpy(buf, &header, sizeof(HEADER));
    memcpy(buf+sizeof(HEADER), &id, sizeof(id));
}

void sendPromise(struct sockaddr_in senderAddr) {
    // format: VIEW_PROMISE, view_number, totalLogLen, replicaID, 
    // Requestlen, Request, Request_view_number
    char temp[BUFFER_SIZE];
    HEADER header = VIEW_PROMISE;
    char* bufp=temp;
    memcpy(bufp, &header, sizeof(HEADER));
    bufp += sizeof(HEADER);
    memcpy(bufp, &view, sizeof(view));
    bufp += sizeof(view);
    int k=0;
    for(auto it=acceptLog.begin(); it!=acceptLog.end(); it++) {
        // count number
        if(it->second != 0) {
            // skip holes
            k++;
        }
    }
    memcpy(bufp, &k, sizeof(k));
    bufp += sizeof(k);
    memcpy(bufp, &id, sizeof(id));
    bufp += sizeof(id);
    for(auto it=acceptLog.begin(); it!=acceptLog.end(); it++) {
        // send entries individuallys
        if(it->second != 0) {
            // skip holes
            int msglen = sizeof(HEADER) + sizeof(view) + sizeof(k) + sizeof(id);
            unsigned rl = sizeof(it->first);
            memcpy(bufp, & rl, sizeof(rl));
            memcpy(bufp+sizeof(rl), & it->first, rl);
            memcpy(bufp+rl+sizeof(rl), & it->second, sizeof(it->second));
            sendto(fd, temp, msglen+sizeof(rl)+rl+sizeof(it->second), 0, (struct sockaddr*) &senderAddr, sizeof(senderAddr));
            // cout << (*(int*) (temp+msglen+sizeof(rl)+rl)) << endl;
        }
    }
}